import {
  type ActionsResult,
  applyDocumentActions,
  type ApplyDocumentActionsOptions,
  type DocumentAction,
  sourceFor,
} from '@sanity/sdk'
import {type SanityDocument} from 'groq'

import {type SourceOptions} from '../../type'
import {useSanityInstanceAndSource} from '../context/useSanityInstance'
// this import is used in an `{@link useEditDocument}`
// eslint-disable-next-line unused-imports/no-unused-imports, import/consistent-type-specifier-style
import type {useEditDocument} from './useEditDocument'

/**
 * @public
 */
interface UseApplyDocumentActions {
  (
    sourceOptions?: SourceOptions,
  ): <
    TDocumentType extends string = string,
    TDataset extends string = string,
    TProjectId extends string = string,
  >(
    action:
      | DocumentAction<TDocumentType, TDataset, TProjectId>
      | DocumentAction<TDocumentType, TDataset, TProjectId>[],
    options?: ApplyDocumentActionsOptions,
  ) => Promise<ActionsResult<SanityDocument<TDocumentType, `${TProjectId}.${TDataset}`>>>
}

/**
 * @public
 *
 * Provides a stable callback function for applying one or more document actions.
 *
 * This hook wraps the core `applyDocumentActions` functionality from `@sanity/sdk`,
 * integrating it with the React component lifecycle and {@link SanityInstance}.
 * It allows you to apply actions generated by functions like `createDocument`,
 * `editDocument`, `deleteDocument`, `publishDocument`, `unpublishDocument`,
 * and `discardDocument` to documents.
 *
 * Features:
 * - Applies one or multiple `DocumentAction` objects.
 * - Supports optimistic updates: Local state reflects changes immediately.
 * - Handles batching: Multiple actions passed together are sent as a single atomic transaction.
 * - Integrates with the collaborative editing engine for conflict resolution and state synchronization.
 *
 * @category Documents
 * @returns A stable callback function. When called with a single `DocumentAction` or an array of `DocumentAction`s,
 * it returns a promise that resolves to an {@link ActionsResult}. The `ActionsResult` contains information about the
 * outcome, including optimistic results if applicable.
 *
 * @remarks
 * This hook is a fundamental part of interacting with document state programmatically.
 * It operates within the same unified pipeline as other document hooks like `useDocument` (for reading state)
 * and {@link useEditDocument} (a higher-level hook specifically for edits).
 *
 * When multiple actions are provided in a single call, they are guaranteed to be submitted
 * as a single transaction to Content Lake. This ensures atomicity for related operations (e.g., creating and publishing a document).
 *
 * @function
 *
 * @example Publish or unpublish a document
 * ```tsx
 * import {
 *   publishDocument,
 *   unpublishDocument,
 *   useApplyDocumentActions,
 *   type DocumentHandle
 * } from '@sanity/sdk-react'
 *
 * // Define props using the DocumentHandle type
 * interface PublishControlsProps {
 *   doc: DocumentHandle
 * }
 *
 * function PublishControls({doc}: PublishControlsProps) {
 *   const apply = useApplyDocumentActions()
 *
 *   const handlePublish = () =>  apply(publishDocument(doc))
 *   const handleUnpublish = () => apply(unpublishDocument(doc))
 *
 *   return (
 *     <>
 *       <button onClick={handlePublish}>Publish</button>
 *       <button onClick={handleUnpublish}>Unpublish</button>
 *     </>
 *   )
 * }
 * ```
 *
 * @example Create and publish a new document
 * ```tsx
 * import {
 *   createDocument,
 *   publishDocument,
 *   createDocumentHandle,
 *   useApplyDocumentActions
 * } from '@sanity/sdk-react'
 *
 * function CreateAndPublishButton({documentType}: {documentType: string}) {
 *   const apply = useApplyDocumentActions()
 *
 *   const handleCreateAndPublish = () => {
 *     // Create a new handle inside the handler
 *     const newDocHandle = createDocumentHandle({ documentId: crypto.randomUUID(), documentType })
 *
 *     // Apply multiple actions for the new handle as a single transaction
 *     apply([
 *       createDocument(newDocHandle),
 *       publishDocument(newDocHandle),
 *     ])
 *   }
 *
 *   return (
 *     <button onClick={handleCreateAndPublish}>
 *       I'm feeling lucky
 *     </button>
 *   )
 * }
 * ```
 */
export const useApplyDocumentActions: UseApplyDocumentActions = (hookOptions = {}) => {
  const [instance, source] = useSanityInstanceAndSource(hookOptions)

  return (actionOrActions, options) => {
    const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]

    let projectId
    let dataset
    for (const action of actions) {
      if (action.projectId) {
        if (!projectId) projectId = action.projectId
        if (action.projectId !== projectId) {
          throw new Error(
            `Mismatched project IDs found in actions. All actions must belong to the same project. Found "${action.projectId}" but expected "${projectId}".`,
          )
        }

        if (action.dataset) {
          if (!dataset) dataset = action.dataset
          if (action.dataset !== dataset) {
            throw new Error(
              `Mismatched datasets found in actions. All actions must belong to the same dataset. Found "${action.dataset}" but expected "${dataset}".`,
            )
          }
        }
      }
    }

    if (projectId && dataset) {
      return applyDocumentActions(instance, {
        actions,
        ...options,
        source: sourceFor({projectId, dataset}),
      })
    }

    return applyDocumentActions(instance, {actions, ...options, source})
  }
}
