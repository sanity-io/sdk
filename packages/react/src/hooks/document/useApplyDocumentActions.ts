import {
  type ActionsResult,
  applyDocumentActions,
  type ApplyDocumentActionsOptions,
  type DocumentAction,
} from '@sanity/sdk'
import {type SanityDocument} from 'groq'
import {useContext} from 'react'

import {SourcesContext} from '../../context/SourcesContext'
import {useSanityInstance} from '../context/useSanityInstance'
import {
  normalizeSourceOptions,
  type WithSourceNameSupport,
} from '../helpers/useNormalizedSourceOptions'
// this import is used in an `{@link useEditDocument}`
// eslint-disable-next-line unused-imports/no-unused-imports, import/consistent-type-specifier-style
import type {useEditDocument} from './useEditDocument'

/**
 * @public
 */
interface UseApplyDocumentActions {
  (): <
    TDocumentType extends string = string,
    TDataset extends string = string,
    TProjectId extends string = string,
  >(
    action:
      | DocumentAction<TDocumentType, TDataset, TProjectId>
      | DocumentAction<TDocumentType, TDataset, TProjectId>[],
    options?: WithSourceNameSupport<ApplyDocumentActionsOptions>,
  ) => Promise<ActionsResult<SanityDocument<TDocumentType, `${TProjectId}.${TDataset}`>>>
}

/**
 * @public
 *
 * Provides a stable callback function for applying one or more document actions.
 *
 * This hook wraps the core `applyDocumentActions` functionality from `@sanity/sdk`,
 * integrating it with the React component lifecycle and {@link SanityInstance}.
 * It allows you to apply actions generated by functions like `createDocument`,
 * `editDocument`, `deleteDocument`, `publishDocument`, `unpublishDocument`,
 * and `discardDocument` to documents.
 *
 * Features:
 * - Applies one or multiple `DocumentAction` objects.
 * - Supports optimistic updates: Local state reflects changes immediately.
 * - Handles batching: Multiple actions passed together are sent as a single atomic transaction.
 * - Integrates with the collaborative editing engine for conflict resolution and state synchronization.
 *
 * @category Documents
 * @returns A stable callback function. When called with a single `DocumentAction` or an array of `DocumentAction`s,
 * it returns a promise that resolves to an {@link ActionsResult}. The `ActionsResult` contains information about the
 * outcome, including optimistic results if applicable.
 *
 * @remarks
 * This hook is a fundamental part of interacting with document state programmatically.
 * It operates within the same unified pipeline as other document hooks like `useDocument` (for reading state)
 * and {@link useEditDocument} (a higher-level hook specifically for edits).
 *
 * When multiple actions are provided in a single call, they are guaranteed to be submitted
 * as a single transaction to Content Lake. This ensures atomicity for related operations (e.g., creating and publishing a document).
 *
 * @function
 *
 * @example Publish or unpublish a document
 * ```tsx
 * import {
 *   publishDocument,
 *   unpublishDocument,
 *   useApplyDocumentActions,
 *   type DocumentHandle
 * } from '@sanity/sdk-react'
 *
 * // Define props using the DocumentHandle type
 * interface PublishControlsProps {
 *   doc: DocumentHandle
 * }
 *
 * function PublishControls({doc}: PublishControlsProps) {
 *   const apply = useApplyDocumentActions()
 *
 *   const handlePublish = () =>  apply(publishDocument(doc))
 *   const handleUnpublish = () => apply(unpublishDocument(doc))
 *
 *   return (
 *     <>
 *       <button onClick={handlePublish}>Publish</button>
 *       <button onClick={handleUnpublish}>Unpublish</button>
 *     </>
 *   )
 * }
 * ```
 *
 * @example Create and publish a new document
 * ```tsx
 * import {
 *   createDocument,
 *   publishDocument,
 *   createDocumentHandle,
 *   useApplyDocumentActions
 * } from '@sanity/sdk-react'
 *
 * function CreateAndPublishButton({documentType}: {documentType: string}) {
 *   const apply = useApplyDocumentActions()
 *
 *   const handleCreateAndPublish = () => {
 *     // Create a new handle inside the handler
 *     const newDocHandle = createDocumentHandle({ documentId: crypto.randomUUID(), documentType })
 *
 *     // Apply multiple actions for the new handle as a single transaction
 *     apply([
 *       createDocument(newDocHandle),
 *       publishDocument(newDocHandle),
 *     ])
 *   }
 *
 *   return (
 *     <button onClick={handleCreateAndPublish}>
 *       I'm feeling lucky
 *     </button>
 *   )
 * }
 * ```
 *
 * @example Create a document with initial field values
 * ```tsx
 * import {
 *   createDocument,
 *   createDocumentHandle,
 *   useApplyDocumentActions
 * } from '@sanity/sdk-react'
 *
 * function CreateArticleButton() {
 *   const apply = useApplyDocumentActions()
 *
 *   const handleCreateArticle = () => {
 *     const newDocHandle = createDocumentHandle({
 *       documentId: crypto.randomUUID(),
 *       documentType: 'article'
 *     })
 *
 *     // Create document with initial values in one action
 *     apply(
 *       createDocument(newDocHandle, {
 *         title: 'New Article',
 *         author: 'John Doe',
 *         publishedAt: new Date().toISOString(),
 *       })
 *     )
 *   }
 *
 *   return <button onClick={handleCreateArticle}>Create Article</button>
 * }
 * ```
 */
export const useApplyDocumentActions: UseApplyDocumentActions = () => {
  const instance = useSanityInstance()
  const sources = useContext(SourcesContext)

  return (actionOrActions, options) => {
    const actions = Array.isArray(actionOrActions) ? actionOrActions : [actionOrActions]
    const normalizedOptions = options ? normalizeSourceOptions(options, sources) : undefined

    let projectId
    let dataset
    let source
    for (const action of actions) {
      if (action.projectId) {
        if (source) {
          throw new Error(
            `Mismatches between projectId/dataset options and source in actions. Found projectId "${action.projectId}" and dataset "${action.dataset}" but expected source "${source}".`,
          )
        }
        if (!projectId) projectId = action.projectId
        if (action.projectId !== projectId) {
          throw new Error(
            `Mismatched project IDs found in actions. All actions must belong to the same project. Found "${action.projectId}" but expected "${projectId}".`,
          )
        }

        if (action.dataset) {
          if (!dataset) dataset = action.dataset
          if (action.dataset !== dataset) {
            throw new Error(
              `Mismatched datasets found in actions. All actions must belong to the same dataset. Found "${action.dataset}" but expected "${dataset}".`,
            )
          }
        }
      }

      if (action.source) {
        if (!source) source = action.source
        if (action.source !== source) {
          throw new Error(
            `Mismatched sources found in actions. All actions must belong to the same source. Found "${action.source}" but expected "${source}".`,
          )
        }
        if (projectId || dataset) {
          throw new Error(
            `Mismatches between projectId/dataset options and source in actions. Found "${action.source}" but expected project "${projectId}" and dataset "${dataset}".`,
          )
        }
      }
    }

    if (projectId || dataset) {
      const actualInstance = instance.match({projectId, dataset})
      if (!actualInstance) {
        throw new Error(
          `Could not find a matching Sanity instance for the requested action: ${JSON.stringify({projectId, dataset}, null, 2)}.
  Please ensure there is a ResourceProvider component with a matching configuration in the component hierarchy.`,
        )
      }

      return applyDocumentActions(actualInstance, {
        actions,
        source,
        ...normalizedOptions,
      })
    }

    return applyDocumentActions(instance, {
      actions,
      source,
      ...normalizedOptions,
    })
  }
}
